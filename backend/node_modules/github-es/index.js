var EsBuilder = require('./esBuilder')
var GitHubBuilder = require('./gitHubBuilder')
module.exports = esGithubWriter

var prMetadata = require('./entities/pull-request-metadata.js')
var prEntity = require('./entities/pullRequest.js')
var memberEntity = require('./entities/member.js')
var coordinatorFactory = require('./entities/coordinator.js')
var teamWriter = require('./entities/team.js');
var integrityChecker = require('./integrityChecker.js');
var teamsLoaderFactory = require('./teamsLoader.js');

function esGithubWriter(gitHubToken, elasticsearchEndpoint) {
    console.log(gitHubToken, elasticsearchEndpoint)
    client = EsBuilder(elasticsearchEndpoint)
    github = GitHubBuilder(gitHubToken)
    
    return result = {

        loaded: 0,
        ids: {},

        coordinatorObj: coordinatorFactory.get({
            client,
            useQueue: true
        }),

        checkIntegrity: function(region, queueUrl) {
            integrityChecker(github, client, region, queueUrl).checkIntegrity();
        },

        loadPartnersStatistic: function() {
            return teamsLoaderFactory(client).getTeams();
        },

        synchronizeTeams: function(orgName) {
            promises = []

            function processOrg(orgResponse) {

                return new Promise(function(resolve, reject) {

                    organization = orgResponse.data;
                    function processTeam(teamsResponse) {

                        return new Promise(function(resolve, reject) {
                            promises = [];
                            teamsResponse.data.map(function(team) {
                                console.log('Team Name', team.name)
                                function processMembers(membersResponse) {
                                    return new Promise(function(resolve, reject) {
                                        this.processMembers(membersResponse, team).then(resolve).catch(reject)
                                    }.bind(this))
                                }
                                promises.push(this.createTeam({team: team, organization: organization}))
                                promises.push(this.scrollingLoad(github.orgs.getTeamMembers, {id: team.id}, processMembers.bind(this)))
                            }.bind(this))
                            Promise.all(promises).then(resolve).catch(reject)
                        }.bind(this))
                    }
                    this.scrollingLoad(github.orgs.getTeams, {org: organization.login}, processTeam.bind(this)).then(resolve).catch(reject)
                }.bind(this))
            }

            github.orgs.get({org: orgName}).then(processOrg.bind(this)).then(function(res) {
                ///console.log(res)
                this.coordinatorObj.getQueueSize();
                this.coordinatorObj.processQueue();
            }.bind(this))
        },

        scrollingLoad: function(func, params, callback) {
            self = this;
            function processResults(res) {
                return new Promise(function(resolve, reject) {
                    //console.log(func, params);
                    //callbackFunc = callback.bind(self);
                    callback(res).then(function() {
                        if (github.hasNextPage(res)) {
                            github.getNextPage(res, function(err, res) {
                                processResults(res).then(resolve).catch(reject)
                            });
                        } else {
                            resolve('Finally');
                        }
                    }).catch(reject)
                });    
            }
            return func(params).then(processResults);
        },

        synchronizeIndividualTeam(teamIds) {
            return new Promise((resolve, reject) => {
                try {
                    teamsPromises = [];
                    teamIds.map(teamId => {
                        teamsPromises.push(github.orgs.getTeam({id: teamId}).then(teamResponse => {
                            promises = [];
                            //console.log(teamResponse);
                            team = teamResponse.data;
                            function processMembers(membersResponse) {
                                return this.processMembers(membersResponse, team)  
                            }
                            promises.push(this.createTeam({team: team, organization: team.organization}))
                            promises.push(this.scrollingLoad(github.orgs.getTeamMembers, {id: team.id}, processMembers.bind(this)))
                            return Promise.all(promises).then(result => {
                                'process queue team'
                                return this.coordinatorObj.processQueue();
                            })
                        }));
                    })
                    Promise.all(teamsPromises).then(resolve).catch(e => {
                        //console.log('team search promises', e)
                        if (e.code == 404) {
                            console.log('Some Team not found', teamIds)
                            resolve('some team not found');
                        } else {
                            reject(e)
                        }
                    })
                } catch (e) {
                    reject(e)
                }
            })
        },

        synchronizeIndividualPRs(prsRequests) {
            console.log(prsRequests)
            // github.issues.getLabels({
            //     owner: 'magento',
            //     repo: 'magento2',
            //     page: '0',
            //     per_page: '10'
            // }).then(labels => {
            //     console.log(labels);
            // })

            // github.issues.getEventsTimeline(
            //     {
            //         owner: 'magento',
            //         repo: 'magento2',
            //         issue_number: 10939,
            //         page: 0,
            //         per_page: 10
            //     }
            // ).then(labels => {
            //         console.log(labels);
            //     })


                // github.issues.getIssueLabels(
                //     {owner: 'magento',
                // repo: 'magento2',
                // number: 10924}).then(labels => {
                //     console.log(labels);
                // })

            promises = [];
            prsRequests.map(prsRequest => {
                console.log(prsRequest);
                promises.push(
                    github.pullRequests.get(prsRequest)
                )
            })
            console.log(promises);
            return Promise.all(promises).then(promisesResult => {
                //console.log('github Request Result', promisesResult);
                esPromises = []
                promisesResult.map(result => {
                    esPromises.push(github.issues.getIssueLabels({
                        owner: result.data.base.user.login,
                        repo: result.data.base.repo.name,
                        number: result.data.number
                    }).then(labels => {
                        return this.writePullRequest(result.data, labels.data)
                    }))
                    //esPromises.push(this.writePullRequest(result.data)
                })
                // console.log(esPromises)
                return Promise.all(esPromises)
            }).then(result => {
                console.log('process queue prs')
                return this.coordinatorObj.processQueue();
            })
        },

        synchronizePullRequests: function(repoRequest) {
            function processResults(res) {
                //console.log('processResults', res.data.length);
                return new Promise((resolve, reject) => {
                    try {
                        //console.log(res);
                        promises = [];
                        skip = false;
                        this.loaded += res.data.length;
                        res.data.map(function(pr) {
                            nDaysAgo = new Date();
                            n = 1
                            nDaysAgo = nDaysAgo.setDate(nDaysAgo.getDate() - n);
                            updatedDate = new Date(pr.updated_at);
                            //console.log(pr.base.repo.full_name, pr.number, pr.updated_at);
                            if (updatedDate < nDaysAgo) {
                                //console.log('skipping the rest');
                                //skip = true;
                            }
                            promises.push(github.issues.getIssueLabels({
                                owner: pr.base.user.login,
                                repo: pr.base.repo.name,
                                number: pr.number
                            }).then(labels => {
                                return this.writePullRequest(pr, labels.data)
                            }))
                                
                                
                                //this.writePullRequest(pr))
                            this.ids[pr.id] = true
                        }, this)
                        //console.log('Size Added to Queue:')
                        //console.log(promises)
                        return Promise.all(promises).then(promisesResult => {
                            //console.log('executed all promises', promisesResult);
                            if (skip) {
                                console.log('Skipped')
                            }
                            if (github.hasNextPage(res) && !skip) {
                                //console.log("Has Next Page")
                                github.getNextPage(res).then(results => {
                                    console.log("process next page", results.data.length)
                                    return processResults.call(this, results)
                                }).then(resolve).catch(reject)
                            } else {
                                resolve('Finally');
                            }
                        }).catch(function(e) {console.log('ErrorRejected:', e); reject(e)})
                    } catch (e) {
                        console.log('Error: ' + e);
                        reject (e);
                    }
                })
            }
            repoRequest.page = 1;
            repoRequest.per_page = 50;
            github.pullRequests.getAll(repoRequest).then(processResults.bind(this)).then(res => {
                console.log(res)
                this.coordinatorObj.processQueue()
                    .then((result) => {
                        console.log(process.memoryUsage())
                        console.log(this.coordinatorObj.getStat())
                        //console.log(this.coordinatorObj.getStat().added['github-prs'].ids)
                        console.log('Loaded ' + this.loaded);
                        //console.log(this.ids)
                    }).catch(e => console.log('New Error: ' + e ))
            }).catch(e => console.log('Latest Error: ' + e ))
        },

        processWebHook: function(event, body) {
            switch (event) {
                case 'membership': this.processMembership(body); break;
                case 'team': this.processTeamWebhook(body); break;
                case 'pull_request': this.processPRWebhook(body); break;
                default:
                    console.log('default unprocessed event: ' + event);
                    //console.log(body)
                    break;
            }
        },

        createTeam: function(body) {
            team = body.team;
            console.log('team', team);
            team.organization = {login: body.organization.login, id: body.organization.id};
            team.members = []
            //console.log('coordinator object id: ', Object.id(this.coordinatorObj));
            return this.coordinatorObj.createOrUpdate({index: 'github-teams', type: 'github-team'}, teamWriter, team, {}, {idField: 'id'})
        },

        processTeamWebhook: function(body)
        {
            console.log('process team webhook')
            this.coordinatorObj.getQueueSize()
            switch(body.action) {
                case "created":
                    this.createTeam(body).then(function() {
                        console.log('Create Team', body);
                        this.coordinatorObj.getQueueSize();
                        this.coordinatorObj.processQueue().then(function(response) {
                            console.log('queue processed', response)
                        }).catch(console.log)
                    }.bind(this)).catch(console.log)
                    break;
            }
        },

        writePullRequest: function(pullRequest, labels = []) {
            //console.log('write pull request', pullRequest.id)

            function getPrMetadata() {
                return {
                    id: this.id,
                    user_id: this.user.id,
                    number: this.number,
                    title: this.title,
                    body: this.body,
                    created_at: this.created_at,
                    updated_at: this.updated_at,
                    closed_at: this.closed_at,
                    merged_at: this.marged_at,
                    merge_commit_sha: this.merge_commit_sha,
                    assignee: this.assignee ? this.assignee.id : null,
                    merged_at: this.merged_at,
                    mergeable: this.mergeable,
                    rebaseable: this.rebaseable,
                    mergeable_state: this.mergeable_state,
                    merged_by: this.merged_by,
                    comments: this.comments,
                    review_comments: this.review_comments,
                    maintainer_can_modify: this.maintainer_can_modify,
                    commits: this.commits,
                    additions: this.additions,
                    deletions: this.deletions,
                    changed_files: this.changed_files,
                    baseOrganisation: this.base.user.login,
                    baseRepo: this.base.repo.name,
                    labels: labels
                }
            }
            return Promise.all([
                this.coordinatorObj.createOrUpdate({index: 'github-prs-metadata', type: 'github-pr-metadata'}, prMetadata, getPrMetadata.call(pullRequest), {}, {idField: 'id', override: true}),

                this.coordinatorObj.createOrUpdate({index: 'github-members', type: 'github-member'}, memberEntity, pullRequest.user, {prs: [pullRequest.id]}, {idField: 'id'}),

                this.coordinatorObj.createOrUpdate({index: 'github-prs', type: 'github-pr'}, prEntity, pullRequest, {}, {idField: 'id', override: true})
            ])
        },

        processMembers: function(membersResponse, teamData) {                
            members = []
            promises = []
            membersResponse.data.map(function(member) {
                console.log('Member Name', teamData.name, member.login)
                members.push(member.id);
                promises.push(this.coordinatorObj.createOrUpdate({index: 'github-members', type: 'github-member'}, 
                    memberEntity, member, {teams: [{id: teamData.id, name: teamData.name}]}, {idField: 'id'}))
            }.bind(this));
            //console.log(teamData.name, membersResponse.data.length, members);
            //team.organization = {login: organization.login, id: organization.id};
            //team.members = members
            //console.log("addTeamMembers", team.id, team.name, {members: members})
            promises.push(this.coordinatorObj.createOrUpdate({index: 'github-teams', type: 'github-team'}, teamWriter, teamData, {members: members}, {idField: 'id'}))
            //console.log(promises);
            return Promise.all(promises)
        },

        processMembership: function(body)
        {
            switch(body.action) {
                case "added":
                    this.processMembers({data:[body.member]}, body.team).then(function() {
                        console.log('completed', body.member.login, body.team.name)
                        this.coordinatorObj.getQueueSize();
                        this.coordinatorObj.processQueue().then(console.log).catch(console.log)
                    }.bind(this)).catch(console.log)
                    break;
            }
        },

        processPRWebhook: function(body)
        {
            switch(body.action) {
                case 'synchronize':
                case 'opened':
                case 'edited':
                case 'reopened':
                    this.writePullRequest(body.pull_request).then(result => {
                        this.coordinatorObj.processQueue().then(console.log).catch(console.log)
                    })
                    break;
                case 'labeled':
                    this.writePullRequest(body.pull_request, [body.label]).then(result => {
                        this.coordinatorObj.processQueue().then(console.log).catch(console.log)
                    })
                    break;
                default: 
                    console.log('default unprocessed action: ' + body.action);
                    break;
            }
        }
    }
}