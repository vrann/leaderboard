/** 
 * @api
 * 
 * config = {
 *      idField: 'myId'
 * }
 * 
 * coordinatorFactory.get({
 *      elasticsearchEndpount: 'http://localhost:9200',
 *      index: 'my-index',
 *      type: 'my-type'
 * }).createOrUpdate({index: 'my-index', type: 'my-type'}, entityFactory, data, updateDate, config);
*/
(function() {
    if ( typeof Object.id == "undefined" ) {
        var id = 0;

        Object.id = function(o) {
            if ( typeof o.__uniqueid == "undefined" ) {
                Object.defineProperty(o, "__uniqueid", {
                    value: ++id,
                    enumerable: false,
                    // This could go either way, depending on your 
                    // interpretation of what an "id" is
                    writable: false
                });
            }

            return o.__uniqueid;
        };
    }
})();

var coordinatorFactory = {
    get: function(config) {
        //console.log(config)
        var useQueue =  config.hasOwnProperty('useQueue') ? config.useQueue : false;
        return coordinator(config.client, useQueue);
    }
}

var coordinator = function(client, useQueue) {
    return {
        useQueue: useQueue,
        queue: [],
        MAX_QUEUE_LENGTH: 50,
        writeMap: {},
        stat: {
            added: {}, 
            processed: {},
            rejected: {},
            combined: {}
        },

        processQueue: function() {
            return new Promise((resolve, reject) => {
                try {
                    //console.log("processing queue", this.queue)
                    //console.log('processing queue: ', Object.id(this.queue), this.queue.length);
                    if (this.queue.length > 0) {
                        body = {body: []};
                        //console.log(this.writeMap)
                        //console.log('start queue processing')
                        this.queue.map(element => {
                            if (this.writeMap[element._index+element._type].hasOwnProperty(element._id)) {
                                wrapper = this.writeMap[element._index+element._type][element._id];
                                body.body.push(wrapper.meta)
                                body.body.push(wrapper.doc)
                                //console.log(wrapper.doc)
                            } else {
                                console.log('wrapper not found:', element._index+element._type, element._id)
                            }
                        })

                        this.queue = [];
                        client.bulk(body)
                        .then(function(response) {
                            //console.log("bulk operation executed")
                            //console.log("Response", response)
                            response.items.map(function(item) {
                                //console.log(item)
                                var element = null;
                                if (item.hasOwnProperty('update')) {
                                    element = item.update
                                } else if (item.hasOwnProperty('create')) {
                                    element = item.create
                                }
                                //console.log(element._id, element.status)
                                if (element != null && element.status == 409) {
                                    if (!this.stat.rejected.hasOwnProperty(element._index)) {
                                        this.stat.rejected[element._index] = 0
                                    }
                                    this.stat.rejected[element._index]++;
                                    if (this.writeMap[element._index+element._type].hasOwnProperty(element._id)) {
                                        console.log('Object has been found', element._id)
                                        failedObject = this.writeMap[element._index+element._type][element._id];
                                        
                                        updateObj = {}
                                        newObj = {}
                                        if (failedObject.hasOwnProperty('meta') && failedObject.meta.hasOwnProperty('update')) {
                                            updateObj = failedObject.doc.doc
                                            newObj = {id: element._id}
                                        } else {
                                            newObj = failedObject.doc;
                                        }
        
                                        if (!this.queue.find(function(queueElement) {return element._index == queueElement._index && queueElement._id == element._id})) {
                                            //delete this.writeMap[element._index+element._type][element._id]
                                            //console.log('deleted from map', element);
                                        } else {
                                            //console.log('still in queue');
                                        }
                                        this.createOrUpdate(
                                            {index: element._index, type: element._type, id: element._id},
                                            failedObject.entity,
                                            newObj,
                                            updateObj,
                                            {},
                                            useQueue
                                        ).then(resolve).catch(reject)
                                    } else {
                                        console.log('Object hasn\'t been found', element._id, element)
                                    }
                                } else {
                                    if (!this.stat.processed.hasOwnProperty(element._index)) {
                                        this.stat.processed[element._index] = 0
                                    }
                                    this.stat.processed[element._index]++;
                                    if (!this.queue.find(function(queueElement) {return element._index == queueElement._index && queueElement._id == element._id})) {
                                        //delete this.writeMap[element._index+element._type][element._id]
                                        //console.log('deleted from map', element);
                                    } else {
                                        //console.log('still in queue');
                                    }
                                }
                            }.bind(this))
                            //console.log('bulk operation executed, response processed', this.queue)                            
                            //this.queue = [];
                            resolve("bulk operation executed, response processed")
                        }.bind(this)).catch(function(e) {
                            console.log(e.lineNumber + e)
                            if (e instanceof EsClientRequestTimeout) {
                                console.log('Request Timed Out..')    
                            }
                            //console.log(e);
                            if (e.status == 409) {
                                //replay queries from the queue one by one using createOrUpdate
                                console.log('409', updateDate)
                                update().then(resolve).catch(reject)
                            } else {
                                reject(e)
                            }
                        })
                    }
                } catch (e) {
                    reject(e.lineNumber + ' ' + e)
                }
            })    
        },

        getQueueSize: function() {
            //console.log(this)
            console.log('queue object id: ', Object.id(this.queue));
            console.log('Queue size is', this.queue.length);
            //console.log(this.queue)
        },

        getStat: function() {
            return this.stat;
        },

        createOrUpdate: function createOrUpdate(params, entity, data, updateDate, config, useQueue) {
            if (!this.stat.added.hasOwnProperty(params.index)) {
                this.stat.added[params.index] = {count: 0, 'ids': {}}
            }
            this.stat.added[params.index]['count']++;
            this.stat.added[params.index]['ids'][data['id']] = true;
            return new Promise(function(resolve, reject) {
                try {
                    idField = config.idField ? config.idField : 'id';
                    //self = this
                    
                    client.indices.exists({index: [params.index]}).then(function(indexExists) {
                        return new Promise(function(resolve, reject) {
                            try {
                                //console.log('Create or update', params.index, data[idField])
                                if (indexExists) {
                                    client.exists({
                                        index: params.index,
                                        type: params.type,
                                        id: data[idField]
                                    }).then(function(documentExists) {
                                        //console.log(documentExists, {
                                        //    index: params.index,
                                        //    type: params.type,
                                        //    id: data[idField]
                                        //})
                                        if (documentExists) {
                                            //console.log('Create', params.index, data[idField])
                                            update.call(this).then(resolve).catch(function (e) {console.log(e.lineNumber + e); reject(e)})
                                        } else {
                                            //console.log('update', params.index, data[idField])
                                            create.call(this).then(resolve).catch(function (e) {console.log(e.lineNumber + e); reject(e)})
                                        }
                                    }.bind(this)).catch(function(e) {
                                        if (e instanceof EsClientRequestTimeout) {
                                            console.log('Request Timed Out..')    
                                        }
                                        reject(e)
                                    })
                                } else {
                                    //console.log('Index ' + params.index + ' does not exists');
                                    //console.log('Create', params.index, data[idField])
                                    create.call(this).then(resolve).catch(function (e) {console.log(e.lineNumber + e); reject(e)})
                                }
                            } catch (e) {
                                reject(e)
                            }    
                        }.bind(this))    
                    }.bind(this)).then(resolve).catch(function(e) {
                        if (e instanceof EsClientRequestTimeout) {
                            console.log('Request Timed Out..')    
                        }
                        console.log(e.lineNumber + e);
                        reject(e);
                    })
                } catch(e) {
                    reject(e)
                }    
            }.bind(this))


            function create() {
                idField = config.idField ? config.idField : 'id';
                return new Promise((resolve, reject) => {
                    try {
                        console.log("create", params.index, data[idField])
                        resolveCreating.call(this, resolve, reject).bind(this)
                    } catch(e) {
                        reject(e)
                    } 
                })  
            }

            function update() {
                idField = config.idField ? config.idField : 'id';
                return new Promise((resolve, reject) => {
                    try {
                        console.log("update", params.index, data[idField])
                        //console.log(this.queue.length);
                        client.get({
                            index: params.index,
                            type: params.type,
                            id: data[idField]
                        }).then(document => {
                            try {
                                resolveUpdating.call(this, document, resolve, reject)
                            } catch (e) {
                                reject(e)
                            }    
                        }).catch(function(e) {
                            if (e instanceof EsClientRequestTimeout) {
                                console.log('Request Timed Out..')    
                            }
                            reject(e)
                        });
                    } catch (e) {
                        reject(e);
                    }  
                });
            }

            function resolveCreating(resolve, reject) {
                idField = config.idField ? config.idField : 'id';
                //console.log(this.queue.length);
                if (this.useQueue && this.queue.length > this.MAX_QUEUE_LENGTH) {
                    this.processQueue();
                        // this.processQueue();
                        // resolve('Queue Processed')
                }

                if (this.useQueue) {
                    //console.log(Object.keys(this), params.index)
                    //console.log("sending to create queue", data[idField], params.index)
                    key = params.index+params.type
                    if (!this.writeMap.hasOwnProperty(key)) {
                        this.writeMap[key] = {}
                    }
                    //console.log(this.writeMap[key], data[idField], params.index)
                    newObj = entity.getCreateObject(data, updateDate, config)
                    //console.log(newObj, data[idField], params.index)
                    if (this.writeMap[key].hasOwnProperty(data[idField])) {
                        //console.log('debout', data[idField], params.index)
                        record = this.writeMap[key][data[idField]]
                        if (!this.stat.combined.hasOwnProperty(params.index)) {
                            this.stat.combined[params.index] = 0
                        }
                        this.stat.combined[params.index]++;
                        if (record.hasOwnProperty('meta') && record.meta.hasOwnProperty('create')) {
                            //console.log('of created with created')
                            newObj = entity.getCreateObject(record.doc, newObj, config)
                            //console.log('debout crt 1', 'Object created', newObj)
                            //console.log(newObj)
                            this.writeMap[key][data[idField]] = {
                                entity: entity,
                                meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                                doc: newObj
                            }
                        } else {
                            newObj = {doc: entity.getCreateObject(record.doc.doc, newObj, config)}
                            //console.log('debout crt 2', newObj, record, updateObj)
                            //console.log('done')
                            //console.log(newObj, record, updateObj)
                            this.writeMap[key][data[idField]] = {
                                entity: entity,
                                meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                                doc: newObj
                            }
                        }
                    } else {
                        //console.log('no conflict', data[idField], params.index)
                        this.writeMap[key][data[idField]] = {
                            entity: entity,
                            meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                            doc: newObj
                        }
                        //console.log(this.writeMap)
                    }
                    //console.log('write to queue: ', Object.id(this.queue));
                    if (!this.queue.find(function(queueElement) {return params.index == queueElement._index && queueElement._id == data[idField]})) {
                        this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                    }
                    //this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                    //this.queue.push({create: {_index: params.index, _type: params.type, _id: data[idField]}})
                    //this.queue.push(entity.getCreateObject(data, updateDate, config));
                    //console.log('sent to queue', this.queue.length)
                    //console.log(this.queue)
                    //console.log('done')
                    resolve('Sent to Queue')
                } else {
                    console.log("no queue", params.index, params.type, data[idField])
                    client.create({
                        index: params.index,
                        type: params.type,
                        id: data[idField],
                        body: entity.getCreateObject(data, updateDate, config)
                    }).then(function(response) {
                        //console.log("created")
                        resolve('Created')
                    }).catch(function(e) {
                        if (e instanceof EsClientRequestTimeout) {
                            console.log('Request Timed Out..')    
                        }
                        //console.log(e);
                        if (e.status == 409) {
                            //console.log('409', updateDate)
                            update.call(this).then(resolve).catch(reject)
                        } else {
                            reject(e)
                        }
                    })
                }
            }
            
            function resolveUpdating(document, resolve, reject) {
                idField = config.idField ? config.idField : 'id';
                
                updateDate = entity.getCreateObject(data, updateDate, config)
                //console.log('update data', updateDate);
                //test update team description
                updateObj = entity.getUpdateObject(document._source, updateDate, config)
                //console.log('document', document._source);                
                //console.log('update object', updateObj);

                if (this.useQueue && this.queue.length > this.MAX_QUEUE_LENGTH) {
                    this.processQueue();
                }

                if (this.useQueue) {
                    key = params.index+params.type
                    if (!this.writeMap.hasOwnProperty(key)) {
                        this.writeMap[key] = {}
                    }
                    if (this.writeMap[key].hasOwnProperty(data[idField])) {
                        //console.log('debout')
                        if (!this.stat.combined.hasOwnProperty(params.index)) {
                            this.stat.combined[params.index] = 0
                        }
                        this.stat.combined[params.index]++;
                        record = this.writeMap[key][data[idField]]
                        //console.log('of updated')
                        if (record.hasOwnProperty('meta') && record.meta.hasOwnProperty('create')) {
                            //console.log('with created')
                            //console.log(record, updateObj)
                            newObj = {doc: entity.getCreateObject(record.doc, updateObj, config)}
                            //console.log('done')
                            //console.log('debout upd 1', newObj, record, updateObj)
                            this.writeMap[key][data[idField]] = {
                                entity: entity,
                                meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                                doc: newObj
                            }
                        } else {
                            //console.log('with updated')
                            //console.log(record, updateObj)
                            newObj = {doc: entity.getCreateObject(record.doc.doc, updateObj, config)}
                            //console.log('done')
                            //console.log('debout upd 2', newObj, record, updateObj)
                            this.writeMap[key][data[idField]] = {
                                entity: entity,
                                meta: {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                                doc: newObj
                            }
                        }
                        
                    } else {
                        //console.log('no conflict', params.index)
                        this.writeMap[key][data[idField]] = {
                            entity: entity,
                            meta: {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                            doc: {doc: updateObj}
                        }
                    }
                    
                    //console.log('write to queue: ', Object.id(this.queue));
                    if (!this.queue.find(function(queueElement) {return params.index == queueElement._index && queueElement._id == data[idField]})) {
                        this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                    }
                    //console.log("sending to update queue", data[idField], params.index)
                    //this.queue = this.queue.concat([
                    //    {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                    //    {doc: updateObj}       
                    //]);
                    //console.log('done', this.queue.length)
                    resolve('added to Queue')
                } else {    
                    console.log('no queue', params.index, params.type, data[idField]);
                    client.update({
                        index: params.index,
                        type: params.type,
                        id: data[idField],
                        version: document._version,
                        body: {
                            doc: updateObj
                        }
                    }).then(function(response) {
                        //console.log("updated", params.type, data[idField])
                        resolve('Updated' + ' ' + params.type + ' ' + data[idField])
                    }).catch(function(e) {
                        //console.log(e);
                        if (e.status == 409) {
                            //console.log('409', updateDate)
                            update.call(this).then(resolve).catch(reject)
                        } else {
                            reject(e)
                        }
                    }) 
                }
            }
        }
    }
}

module.exports = coordinatorFactory;