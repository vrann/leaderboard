//load prs and check that authors has the pr in its prs
var AWS = require('aws-sdk');
AWS.config.setPromisesDependency(require('bluebird'));

var integrityChecker = function(github, client, region, queueUrl) {
    AWS.config.setPromisesDependency(require('bluebird'));
    return {
        sqs: new AWS.SQS({region: region}),
        prs: {},
        fullPrs: {},
        members: {},
        membersTeams: {},
        teams: {},
        exceptions: [],
        queueUrl: queueUrl,
        prsData: {},

        checkCountPrs: function() {
            return new Promise(function(resolve, reject) {
                //check count of prs on github and internall
                Promise.all([
                    github.getPullRequests({
                        user: 'magento',
                        repo: 'magento2',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento',
                        repo: 'magento2',
                        state: 'open'
                    }),

                    github.getPullRequests({
                        user: 'magento-engcom',
                        repo: 'magento2',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento-engcom',
                        repo: 'magento2',
                        state: 'open'
                    }),

                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ee',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ee',
                        state: 'open'
                    }),

                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ce',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ce',
                        state: 'open'
                    }),

                    client.count({
                        index: 'github-prs',
                        type: 'github-pr',
                        body: {"query": 
                            {match_all:{}}
                        }
                    })
                ]).then(function(res) {
                    var total = 0;
                    var current = 0;
                    res.map(function(singleResult) {
                        if (singleResult.hasOwnProperty('total_count')) {
                            console.log(singleResult.total_count)
                            total += singleResult.total_count;
                        } else if (singleResult.hasOwnProperty('count')) {
                            current = singleResult.count;
                        }
                    })
                    console.log('Total', total, 'In Elastic', current);
                    var documentsToImport = []
                    if (total + 23 > current) {
                        this.exceptions.push({
                            error: 'prs count is less than necessary'
                        })
                        resolve('prs count is less than necessary')
                    } else if (total + 23 < current) {
                        console.log('Excessive PRs');
                        resolve('Excessive PRs')
                    }
                }.bind(this)).catch(reject)
            }.bind(this))
        },

        checkLastUpdatedPrs: function() {
            return new Promise((resolve, reject) => {
                const promises = [];

                [
                    {owner: 'magento', repo: 'magento2'},
                    {owner: 'magento-engcom', repo: 'msi'},
                    {owner: 'magento-partners', repo: 'magento2ce'},
                    {owner: 'magento-partners', repo: 'magento2ee'},
                    {owner: 'vrann-acme', repo: 'test'} 
                ].map (repoRequest => {
                    repoRequest.page = 1;
                    repoRequest.per_page = 50;
                    repoRequest.sort = 'updated';
                    repoRequest.direction = 'desc';
                    ['open', 'closed'].map(state => {
                        repoRequest.state = state;
                        promises.push(github.pullRequests.getAll(repoRequest));
                    })
                })

                Promise.all(promises).then(promisesResult => {
                    //console.log(result);
                    prs = {}
                    promisesResult.map(result => {
                        result.data.map(pr => {
                            prs[parseInt(pr.id)] = pr.updated_at
                            this.prsData[parseInt(pr.id)] = {
                                owner: pr.base.user.login,
                                repo: pr.base.repo.name,
                                number: pr.number
                            }
                        })
                    })
                    
                    client.loadData({
                        index: 'github-prs-metadata',
                        type: 'github-pr-metadata',
                        _source: ["id", "updated_at"],
                        size: 1000,
                        body: {query:{terms:{id: Object.keys(prs)}}}
                    }, prsResponse => {
                        try {
                            //console.log(prsResponse, Object.keys(prs));
                            prsResponse.hits.hits.map(prSaved => {
                                if (new Date(prSaved._source.updated_at) < new Date(prs[prSaved._source.id])) {
                                    this.exceptions.push({
                                        error: 'pr is outdated',
                                        pr: prSaved._source.id
                                    })
                                }
                                delete prs[prSaved._source.id]
                            })
                            Object.keys(prs).map(prId => {
                                this.exceptions.push({
                                    error: 'pr is missing',
                                    pr: prId
                                })
                            })

                            resolve("PR dates are checked")
                        } catch (e) {
                            reject(e)
                        }
                    }, () => {return false})//.then(resolve).catch(reject)
                }).catch(reject);
            })    
        },

        checkIndices: function() {
            return new Promise((resolve, reject) => {
                console.log(Object.keys(this))
                client.indices.exists({index: ['github-prs', 'github-prs-metadata', 'github-teams', 'github-members']}).then(result => {
                    if (!result) {
                        console.log(result)
                        this.exceptions.push({
                            error: 'index does not exists'
                        })
                        reject('Indices does not exists');
                    } else {
                        resolve('All indicies exists');
                    }
                }).catch(reject);
            })
        },

        checkMembers: function(key) {
            return new Promise(function(resolve, reject) {
                key = parseInt(key);
                errors = 0;

                memberPrs = this.members[key];
                memberPrs.map(function(pr){
                    if (!this.prs.hasOwnProperty(pr)) {
                        //console.log('pr creator is not a member');
                        this.exceptions.push({
                            error: 'pr of member is missing',
                            pr: pr,
                            member: key
                        })
                        errors++;
                    } else if (this.prs[pr] != key) {
                        //console.log('pr creator is not a member');
                        this.exceptions.push({
                            error: 'pr creator is not a member',
                            pr: pr,
                            member: key
                        })
                        errors++
                    }
                }, this)

                memberTeams = this.membersTeams[key];
                memberTeams.map(team => {
                    if (!this.teams.hasOwnProperty(team.id)) {
                        this.exceptions.push({
                            error: 'team is missing',
                            team: team.id
                        })

                        errors++
                    } else if (this.teams[team.id].indexOf(key) == -1){
                        this.exceptions.push({
                            error: 'team does not have member',
                            team: team.id,
                            member: key
                        })
                        errors++
                    }
                })

                resolve("Members Checked")
            }.bind(this))
        },

        checkPrs: function(key) {
            if (key == 'undefined') {
                console.log('Error checkPRs')
            }
                //key = parseInt(key);
                member = this.prs[key];
                if (!this.members.hasOwnProperty(member)) {
                    //console.log('member is missing');
                    this.exceptions.push({
                        error: 'member is missing',
                        pr: key,
                        member: member
                    })
                } else if (this.members[member].indexOf(parseInt(key)) == -1) {
                    //console.log('member does not have pr');
                    this.exceptions.push({
                        error: 'member does not have pr',
                        pr: key,
                        member: member
                    })
                }
        },

        checkTeams: function(key) {
            return new Promise((resolve, reject) => {
                errors = 0;
                key = parseInt(key);
                members = this.teams[key];
                members.map(memberId => {
                    if (!this.membersTeams.hasOwnProperty(memberId)) {
                        this.exceptions.push({
                            error: 'member of team is missing',
                            team: key,
                            member: memberId,
                        })
                        errors++
                    } else {
                        if (!this.membersTeams[memberId].indexOf(key) == -1) {
                            this.exceptions.push({
                                error: 'member does not have team',
                                team: membkeyerId,
                                member: memberId,
                            })
                        }
                        errors++
                    }
                })
                resolve("Teams Checked")
            })
        },

        sendExceptions: function(response) {
            //console.log(response, this.exceptions)
            messages = [];
            // this.exceptions.map(function(exception) {
            //     switch (exception.error) {
            //         case 'index does not exists':
            //            messages.push({action: 'syncPRs'}) 
            //            messages.push({action: 'syncTeams'})
            //            break;  
            //     }
            // }.bind(this))
            // if (this.exceptions.length > 0) {
            //     messages.push({action: 'syncPRs'}) 
            //     messages.push({action: 'syncTeams'})
            // }

            this.exceptions.map((exception) => {
                switch (exception.error) {
                    case 'index does not exists':
                        messages.push({action: 'syncPRs'}) 
                        messages.push({action: 'syncTeams'})
                        break;
                    case 'pr is outdated':    
                    case 'pr is missing':    
                    case 'pr creator is not a member':    
                    case 'member is missing':    
                    case 'member does not have pr':
                        console.log(exception.pr, this.prsData[exception.pr]);
                        messages.push({action: 'syncPr', pr: this.prsData[exception.pr]})   
                        break;    
                    case 'member does not have team':
                    case 'member of team is missing':
                    case 'team is missing':
                    case 'team does not have member':
                        messages.push({action: 'syncTeam', id: exception.team})   
                        break;      
                }
            })
            promises = []
            messages.map(function(message) {
                var params = {
                    MessageBody: JSON.stringify(message),
                    QueueUrl: this.queueUrl,
                    DelaySeconds: 0
                }
                promises.push(this.sqs.sendMessage(params).promise())
            }.bind(this))
            console.log(messages, promises);
            return Promise.all(promises)
        },

        prsProcessor: function(item) {
            this.prs[item.id] = item.user_id;
        },

        loadDataElastic: function(config, callback, shouldScroll) {
            config.scroll = '60s';
            callFunc = client.search
            if (config.body.hasOwnProperty('scroll_id')) {
                callFunc = client.scroll
            }
            return callFunc.call(client, config).then(
                response => {
                    callback.call(this, response)
                    if (shouldScroll(response.hits.total)) {
                        return this.loadDataElastic({
                            body: {
                                scroll_id: response._scroll_id
                            }
                        }, callback, shouldScroll)
                    } else {
                        return new Promise(function(resolve, reject) {resolve("Finished")});
                    }
                }
            )
        },

        checkIntegrity: function() {
            this.checkIndices.call(this).then(result => {
                //load prs metadata
                console.log(result, this.exceptions)
                return this.loadDataElastic({
                    index: 'github-prs-metadata',
                    type: 'github-pr-metadata',
                    _source: ["id", "user_id", "baseOrganisation", "baseRepo", "number"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }    
                }, response => {
                    response.hits.hits.forEach(
                        hit => {
                            this.prs[hit._source.id] = hit._source.user_id
                            this.prsData[hit._source.id] = {
                                owner: hit._source.baseOrganisation,
                                repo: hit._source.baseRepo,
                                number: hit._source.number
                            }
                        }
                    );
                }, hitsTotal => {
                    console.log(hitsTotal, Object.keys(this.prs).length)
                    return hitsTotal > Object.keys(this.prs).length
                }).catch(console.log)
            // }).then(result => {
            //     //load prs and check that there is corresponding pr metadata
            //     return this.loadDataElastic({
            //         index: 'github-prs',
            //         type: 'github-pr',
            //         _source: ["id"],
            //         size: 1000,
            //         body: {
            //             query:{
            //                 match_all:{}
            //             }
            //         }    
            //     }, response => {
            //         response.hits.hits.map(item => {
            //             if (!this.prs.hasOwnProperty(item._source.id)) {
            //                 this.exceptions.push({
            //                     error: 'there is no metadata for the pr',
            //                     pr: item.id
            //                 })
            //             }
            //             this.fullPrs[item._source.id] = true;
            //         }, this)
            //     }, hitsTotal => {
            //         console.log(hitsTotal, Object.keys(this.fullPrs).length)
            //         return hitsTotal > Object.keys(this.fullPrs).length
            //     }).catch(console.log)
            // }).then(result => {
            //     Object.keys(this.prs).map(function(id) {
            //         if (!this.fullPrs.hasOwnProperty(id)) {
            //             this.exceptions.push({
            //                 error: 'there is no full pr for metadata',
            //                 pr: id
            //             })
            //         }
            //     }, this)
            //     return new Promise(function(resolve, reject) {resolve("Finished")});
            }).then(result => {
                //load members
                return this.loadDataElastic({
                    index: 'github-teams',
                    type: 'github-team',
                    _source: ["id", "members"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }
                }, response => {
                    response.hits.hits.map(item => {
                        this.teams[item._source.id] = item._source.members;
                    })    
                }, hitsTotal => {
                    //console.log(hitsTotal, Object.keys(this.teams).length)
                    return hitsTotal > Object.keys(this.teams).length
                })
            }).then(result => {
                //load members
                return this.loadDataElastic({
                    index: 'github-members',
                    type: 'github-member',
                    _source: ["id", "prs", "teams"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }
                }, response => {
                    response.hits.hits.map(item => {
                        this.members[item._source.id] = item._source.prs;
                        this.membersTeams[item._source.id] = item._source.teams;
                    })    
                }, hitsTotal => {
                    console.log(hitsTotal, Object.keys(this.members).length)
                    return hitsTotal > Object.keys(this.members).length
                })
            }).then(result => {
                //check that members assigned to pr has the pr
                //console.log(Object.keys(this.prs));
                Object.keys(this.prs).map(this.checkPrs, this)
                return new Promise(function(resolve, reject) {resolve("Finished")});
            }).then(result => {
                 //check that prs assigned to the member has the member
                Object.keys(this.members).map(this.checkMembers, this)
                return new Promise(function(resolve, reject) {resolve("Finished")});
            }).then(result => {
                //check that prs assigned to the member has the member
               Object.keys(this.teams).map(this.checkTeams, this)
               return new Promise(function(resolve, reject) {resolve("Finished")});
           })
            //.then(this.checkCountPrs.bind(this))
            .then(this.checkLastUpdatedPrs.bind(this))
            .then(result => {
                this.exceptions.map(exception => {
                    console.log(exception)
                })
                //console.log(this.exceptions)
                return this.sendExceptions()
            })
            //.then(console.log)
            .catch(response => {
                console.log(response)
                //this.sendExceptions   
            })
        }
    }    
}

module.exports = integrityChecker