/** 
 * @api
 * 
 * config = {
 *      idField: 'myId'
 * }
 * 
 * coordinatorFactory.get({
 *      elasticsearchEndpount: 'http://localhost:9200',
 *      index: 'my-index',
 *      type: 'my-type'
 * }).createOrUpdate({index: 'my-index', type: 'my-type'}, entityFactory, data, updateDate, config);
*/
var coordinatorFactory = {
    get: function(config) {
        //console.log(config)
        var useQueue =  config.hasOwnProperty('useQueue') ? config.useQueue : false;
        return coordinator(config.client, useQueue);
    }
}

var coordinator = function(client, useQueue) {
    return {
        useQueue: useQueue,
        queue: [],
        MAX_QUEUE_LENGTH: 50,
        writeMap: {},

        processQueue: function() {
            return new Promise(function(resolve, reject) {
                //console.log("processing queue", this.queue)
                //console.log('processing queue: ', Object.id(this.queue), this.queue.length);
                if (this.queue.length > 0) {
                    body = {body: []};
                    //console.log(this.writeMap)
                    //console.log('start queue processing')
                    this.queue.map(function(element) {
                        //console.log(element);
                        //console.log(element['_index']+element['_type'], this.writeMap.hasOwnProperty(element['_index']+element['_type']))
                        //, element._id, this.writeMap.hasOwnProperty(element._index+element._type))
                        if (this.writeMap[element._index+element._type].hasOwnProperty(element._id)) {
                            wrapper = this.writeMap[element._index+element._type][element._id];
                            //console.log(wrapper)
                            console.log('wrapper: ')
                            body.body.push(wrapper.meta)
                            body.body.push(wrapper.doc)
                        } else {
                            console.log('wrapper not found:', element._index+element._type, element._id)
                        }
                    }.bind(this))
                    //console.log('Body:', body);
                    //console.log('clearing queue: ', Object.id(this.queue));
                    this.queue = [];
                    client.bulk(body)
                    .then(function(response) {
                        //console.log("bulk operation executed")
                        //console.log(response)
                        response.items.map(function(item) {
                            //console.log(item)
                            var element = null;
                            if (item.hasOwnProperty('update')) {
                                element = item.update
                            } else if (item.hasOwnProperty('create')) {
                                element = item.create
                            }
                            console.log(element._id, element.status)
                            if (element != null && element.status == 409) {
                                // console.log('error document:')
                                // console.log(
                                //     element,
                                //     element._index+element._type, 
                                //     Object.keys(this.writeMap),
                                //     Object.keys(this.writeMap[element._index+element._type]), 
                                //     this.writeMap[element._index+element._type][element._id]
                                // )

                                if (this.writeMap[element._index+element._type].hasOwnProperty(element._id)) {
                                    console.log('Object hasnt been found', element._id)
                                }
                                failedObject = this.writeMap[element._index+element._type][element._id];
                                
                                updateObj = {}
                                newObj = {}
                                if (failedObject.meta.hasOwnProperty('update')) {
                                    updateObj = failedObject.doc.doc
                                    newObj = {id: element._id}
                                } else {
                                    newObj = failedObject.doc;
                                }
                                // console.log('Retry Request: ', 
                                //     element,
                                //     failedObject.entity,
                                //     newObj,
                                //     updateObj)

                                if (!this.queue.find(function(queueElement) {return element._index == queueElement._index && queueElement._id == element._id})) {
                                    delete this.writeMap[element._index+element._type][element._id]
                                } else {
                                    console.log('still in queue');
                                }
                                this.createOrUpdate(
                                    {index: element._index, type: element._type, id: element._id},
                                    failedObject.entity,
                                    newObj,
                                    updateObj,
                                    {},
                                    useQueue
                                ).then(resolve).catch(reject)
                            } else {
                                if (!this.queue.find(function(queueElement) {return element._index == queueElement._index && queueElement._id == element._id})) {
                                    delete this.writeMap[element._index+element._type][element._id]
                                } else {
                                    console.log('still in queue');
                                }
                            }
                        }.bind(this))
                        //console.log('Errors from response', response.items.length)                            
                        //this.queue = [];
                        resolve("bulk operation executed")
                    }.bind(this)).catch(function(e) {
                        if (e instanceof EsClientRequestTimeout) {
                            console.log('Request Timed Out..')    
                        }
                        //console.log(e);
                        if (e.status == 409) {
                            //replay queries from the queue one by one using createOrUpdate
                            //console.log('409', updateDate)
                            update().then(resolve).catch(reject)
                        } else {
                            reject(e)
                        }
                    })
                }
            }.bind(this))    
        },

        getQueueSize: function() {
            //console.log(this)
            console.log('queue object id: ', Object.id(this.queue));
            console.log('Queue size is', this.queue.length);
            //console.log(this.queue)
        },

        createOrUpdate: function createOrUpdate(params, entity, data, updateDate, config, useQueue) {

            return new Promise(function(resolve, reject) {
                try {
                    idField = config.idField ? config.idField : 'id';
                    //self = this
                    
                    client.indices.exists({index: [params.index]}).then(function(indexExists) {
                        return new Promise(function(resolve, reject) {
                            try {
                                //console.log(this.queue.length)
                                //console.log('Create or update', params.index, data[idField])
                                if (indexExists) {
                                    client.exists({
                                        index: params.index,
                                        type: params.type,
                                        id: data[idField]
                                    }).then(function(documentExists) {
                                        //console.log(documentExists, {
                                        //    index: params.index,
                                        //    type: params.type,
                                        //    id: data[idField]
                                        //})
                                        if (documentExists) {
                                            //console.log('Create', params.index, data[idField])
                                            update.call(this).then(resolve).catch(function (e) {console.log(e); reject(e)})
                                        } else {
                                            //console.log('update', params.index, data[idField])
                                            create.call(this).then(resolve).catch(function (e) {console.log(e); reject(e)})
                                        }
                                    }.bind(this)).catch(function(e) {
                                        if (e instanceof EsClientRequestTimeout) {
                                            console.log('Request Timed Out..')    
                                        }
                                        reject(e)
                                    })
                                } else {
                                    //console.log('Index ' + params.index + ' does not exists');
                                    //console.log('Create', params.index, data[idField])
                                    create.call(this).then(resolve).catch(function (e) {console.log(e); reject(e)})
                                }
                            } catch (e) {
                                reject(e)
                            }    
                        }.bind(this))    
                    }.bind(this)).then(resolve).catch(function(e) {
                        if (e instanceof EsClientRequestTimeout) {
                            console.log('Request Timed Out..')    
                        }
                        //console.log(e);
                        reject(e);
                    })
                } catch(e) {
                    reject(e)
                }    
            }.bind(this))


            function create() {
                return new Promise(function(resolve, reject) {
                    try {
                        //console.log(this.queue.length);
                        if (this.useQueue && this.queue.length < this.MAX_QUEUE_LENGTH) {
                            //console.log(Object.keys(this), params.index)
                            //console.log("sending to create queue", data[idField], params.index)
                            key = params.index+params.type
                            if (!this.writeMap.hasOwnProperty(key)) {
                                this.writeMap[key] = {}
                            }
                            //console.log(this.writeMap[key], data[idField], params.index)
                            newObj = entity.getCreateObject(data, updateDate, config)
                            //console.log(newObj, data[idField], params.index)
                            if (this.writeMap[key].hasOwnProperty(data[idField])) {
                                //console.log('conflict', data[idField], params.index)
                                record = this.writeMap[key][data[idField]]
                                if (record.meta.hasOwnProperty('create')) {
                                    //console.log('of created with created')
                                    newObj = entity.getCreateObject(record.doc, newObj, config)
                                    //console.log(newObj)
                                    this.writeMap[key][data[idField]] = {
                                        entity: entity,
                                        meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                                        doc: newObj
                                    }
                                } else {
                                    //console.log('of created with updated')
                                    newObj = {doc: entity.getUpdateObject(newObj, record.doc.doc, config)}
                                    //console.log(newObj)
                                    this.writeMap[key][data[idField]] = {
                                        entity: entity,
                                        meta: {update: {_index: params.index, _type: params.type, _id: data[idField], _version:record.meta.update._version}},
                                        doc: newObj
                                    }
                                }
                            } else {
                                //console.log('no conflict', data[idField], params.index)
                                this.writeMap[key][data[idField]] = {
                                    entity: entity,
                                    meta: {create: {_index: params.index, _type: params.type, _id: data[idField]}},
                                    doc: newObj
                                }
                                //console.log(this.writeMap)
                            }
                            //console.log('write to queue: ', Object.id(this.queue));
                            if (!this.queue.find(function(queueElement) {return params.index == queueElement._index && queueElement._id == data[idField]})) {
                                this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                            }
                            //this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                            //this.queue.push({create: {_index: params.index, _type: params.type, _id: data[idField]}})
                            //this.queue.push(entity.getCreateObject(data, updateDate, config));
                            //console.log('sent to queue', this.queue.length)
                            //console.log(this.queue)
                            resolve('Sent to Queue')
                        } else {
                            if (this.useQueue) {
                                this.processQueue();
                                resolve('Queue Processed')
                            } else {
                                //console.log("creating", params.index)
                                client.create({
                                    index: params.index,
                                    type: params.type,
                                    id: data[idField],
                                    body: entity.getCreateObject(data, updateDate, config)
                                }).then(function(response) {
                                    //console.log("created")
                                    resolve('Created')
                                }).catch(function(e) {
                                    if (e instanceof EsClientRequestTimeout) {
                                        console.log('Request Timed Out..')    
                                    }
                                    //console.log(e);
                                    if (e.status == 409) {
                                        //console.log('409', updateDate)
                                        update.call(this).then(resolve).catch(reject)
                                    } else {
                                        reject(e)
                                    }
                                })
                            }
                        }
                    } catch(e) {
                        reject(e)
                    } 
                }.bind(this))  
            }

            function update() {
                return new Promise(function(resolve, reject) {
                    try {
                        //console.log("update")
                        //console.log(this.queue.length);
                        client.get({
                            index: params.index,
                            type: params.type,
                            id: data[idField]
                        }).then(function(document) {
                            //console.log(this.useQueue)
                            //update
                            updateObj = entity.getUpdateObject(document._source, updateDate, config)
                            //console.log("updating", updateDate, data[idField], params.index)
                            if (this.useQueue && this.queue.length < this.MAX_QUEUE_LENGTH) {
                                key = params.index+params.type
                                if (!this.writeMap.hasOwnProperty(key)) {
                                    this.writeMap[key] = {}
                                }
                                if (this.writeMap[key].hasOwnProperty(data[idField])) {
                                    //console.log('conflict')
                                    record = this.writeMap[key][data[idField]]
                                    //console.log('of updated')
                                    if (record.meta.hasOwnProperty('create')) {
                                        //console.log('with created')
                                        newObj = {doc: entity.getUpdateObject(record.doc, updateObj, config)}
                                        //console.log('done')
                                        //console.log(newObj, record, updateObj)
                                    } else {
                                        //console.log('with updated')
                                        //console.log(record, updateObj)
                                        newObj = {doc: entity.getUpdateObject(record.doc.doc, updateObj, config)}
                                        //console.log('done')
                                        //console.log(newObj, record, updateObj)
                                    }
                                    this.writeMap[key][data[idField]] = {
                                        entity: entity,
                                        meta: {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                                        doc: newObj
                                    }
                                } else {
                                    //console.log('no conflict', params.index)
                                    this.writeMap[key][data[idField]] = {
                                        entity: entity,
                                        meta: {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                                        doc: {doc: updateObj}
                                    }
                                }
                                //console.log('write to queue: ', Object.id(this.queue));
                                if (!this.queue.find(function(queueElement) {return params.index == queueElement._index && queueElement._id == data[idField]})) {
                                    this.queue.push({_index: params.index, _type: params.type, _id: data[idField]})
                                }    

                                //console.log("sending to update queue", data[idField], params.index)
                                //this.queue = this.queue.concat([
                                //    {update: {_index: params.index, _type: params.type, _id: data[idField], _version:document._version}},
                                //    {doc: updateObj}       
                                //]);
                                resolve('added to Queue')
                            } else {    
                                if (this.useQueue) {
                                    this.processQueue();
                                    resolve('Processed Queue')
                                } else {
                                    client.update({
                                        index: params.index,
                                        type: params.type,
                                        id: data[idField],
                                        version: document._version,
                                        body: {
                                            doc: updateObj
                                        }
                                    }).then(function(response) {
                                        //console.log("updated", params.type, data[idField])
                                        resolve('Updated')
                                    }).catch(function(e) {
                                        //console.log(e);
                                        if (e.status == 409) {
                                            //console.log('409', updateDate)
                                            update.call(this).then(resolve).catch(reject)
                                        } else {
                                            reject(e)
                                        }
                                    })
                                }    
                            }    
                        }.bind(this)).catch(function(e) {
                            if (e instanceof EsClientRequestTimeout) {
                                console.log('Request Timed Out..')    
                            }
                            reject(e)
                        });
                    } catch (e) {
                        reject(e);
                    }  
                }.bind(this));
            }    
        }
    }
}

module.exports = coordinatorFactory;