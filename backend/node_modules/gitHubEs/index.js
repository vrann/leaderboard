var EsBuilder = require('./esBuilder')
var GitHubBuilder = require('./gitHubBuilder')
module.exports = esGithubWriter

var prMetadata = require('./entities/pull-request-metadata.js')
var prEntity = require('./entities/pullRequest.js')
var memberEntity = require('./entities/member.js')
var coordinatorFactory = require('./entities/coordinator.js')
var teamWriter = require('./entities/team.js');
var integrityChecker = require('./integrityChecker.js');

function esGithubWriter(gitHubToken, elasticsearchEndpoint) {
    console.log(gitHubToken, elasticsearchEndpoint)
    client = EsBuilder(elasticsearchEndpoint)
    github = GitHubBuilder(gitHubToken)
    
    return result = {

        coordinatorObj: coordinatorFactory.get({
            client,
            useQueue: true
        }),

        checkIntegrity: function(region, queueUrl) {
            integrityChecker(github, client, region, queueUrl).checkIntegrity();
        },

        synchronizeTeams: function(orgName) {
            promises = []

            function processOrg(orgResponse) {

                return new Promise(function(resolve, reject) {

                    organization = orgResponse.data;
                    function processTeam(teamsResponse) {

                        return new Promise(function(resolve, reject) {
                            promises = [];
                            teamsResponse.data.map(function(team) {
                                console.log('Team Name', team.name)
                                function processMembers(membersResponse) {
                                    return new Promise(function(resolve, reject) {
                                        this.processMembers(membersResponse, team).then(resolve).catch(reject)
                                    }.bind(this))
                                }
                                promises.push(this.createTeam({team: team, organization: organization}))
                                promises.push(this.scrollingLoad(github.orgs.getTeamMembers, {id: team.id}, processMembers.bind(this)))
                            }.bind(this))
                            Promise.all(promises).then(resolve).catch(reject)
                        }.bind(this))
                    }
                    this.scrollingLoad(github.orgs.getTeams, {org: organization.login}, processTeam.bind(this)).then(resolve).catch(reject)
                }.bind(this))
            }

            github.orgs.get({org: orgName}).then(processOrg.bind(this)).then(function(res) {
                console.log(res)
                this.coordinatorObj.getQueueSize();
                this.coordinatorObj.processQueue();
            }.bind(this))
        },

        scrollingLoad: function(func, params, callback) {
            self = this;
            function processResults(res) {
                return new Promise(function(resolve, reject) {
                    console.log(func, params);
                    //callbackFunc = callback.bind(self);
                    callback(res).then(function() {
                        if (github.hasNextPage(res)) {
                            github.getNextPage(res, function(err, res) {
                                processResults(res).then(resolve).catch(reject)
                            });
                        } else {
                            resolve('Finally');
                        }
                    }).catch(reject)
                });    
            }
            return func(params).then(processResults);
        },

        synchronizePullRequests: function(repoRequest) {
            function processResults(res) {
                //console.log('processResults', res.data.length);
                return new Promise(function(resolve, reject) {
                    //console.log(res.data.length);
                    promises = [];
                    res.data.map(function(pr) {
                        console.log(pr.id);
                        promises.push(this.writePullRequest(pr))
                    }, this)
                    //console.log(promises)
                    Promise.all(promises).then(function(promisesResult) {
                        //console.log('executed all promises', promisesResult);
                        if (github.hasNextPage(res)) {
                            //console.log("Has Next Page")
                            github.getNextPage(res).then(function(results) {
                                console.log("process next page", results.data.length)
                                return processResults.call(this, results)
                            }.bind(this)).catch(reject).then(resolve).catch(reject)
                        } else {
                            resolve('Finally');
                        }
                    }.bind(this)).catch(function(e) {console.log('ErrorRejected:', e); reject(e)})
                }.bind(this))
            }
            repoRequest.page = 1;
            repoRequest.per_page = 50;
            github.pullRequests.getAll(repoRequest).then(processResults.bind(this)).then(function(res) {
                //console.log(res)
                //this.coordinatorObj.getQueueSize();
                this.coordinatorObj.processQueue().then(console.log).catch(console.log)
            }.bind(this)).catch(console.log)
        },

        processWebHook: function(event, body) {
            switch (event) {
                case 'membership': this.processMembership(body); break;
                case 'team': this.processTeamWebhook(body); break;
                case 'pull_request': this.processPRWebhook(body); break;
                default:
                    console.log('default unprocessed event: ' + event);
                    //console.log(body)
                    break;
            }
        },

        createTeam: function(body) {
            team = body.team;
            team.organization = {login: body.organization.login, id: body.organization.id};
            team.members = []
            console.log('coordinator object id: ', Object.id(this.coordinatorObj));
            return this.coordinatorObj.createOrUpdate({index: 'github-teams', type: 'github-team'}, teamWriter, team, {}, {idField: 'id'})
        },

        processTeamWebhook: function(body)
        {
            console.log('process team webhook')
            this.coordinatorObj.getQueueSize()
            switch(body.action) {
                case "created":
                    this.createTeam(body).then(function() {
                        console.log('Create Team', body);
                        this.coordinatorObj.getQueueSize();
                        this.coordinatorObj.processQueue().then(function(response) {
                            console.log('queue processed', response)
                        }).catch(console.log)
                    }.bind(this)).catch(console.log)
                    break;
            }
        },

        writePullRequest: function(pullRequest) {
            return Promise.all([
                this.coordinatorObj.createOrUpdate({index: 'github-prs-metadata', type: 'github-pr-metadata'}, prMetadata, pullRequest, {}, {idField: 'id', override: true}),

                this.coordinatorObj.createOrUpdate({index: 'github-members', type: 'github-member'}, memberEntity, pullRequest.user, {prs: [pullRequest.id]}, {idField: 'id'}),

                this.coordinatorObj.createOrUpdate({index: 'github-prs', type: 'github-pr'}, prEntity, pullRequest, {}, {idField: 'id', override: true})
            ])    
        },

        processLabel: function(body) {
            config = {
                idField: 'id'
            }
            coordinatorFactory.get({
                client: client,
                index: 'github-prs-metadata',
                type: 'github-pr-metadata'
            }).createOrUpdate(prMetadata, body.pull_request, {action: 'labeled', label: body.label}, config);
        },

        processMembers: function(membersResponse, teamData) {                
            members = []
            promises = []
            membersResponse.data.map(function(member) {
                console.log('Member Name', teamData.name, member.login)
                members.push(member.id);
                promises.push(this.coordinatorObj.createOrUpdate({index: 'github-members', type: 'github-member'}, 
                    memberEntity, member, {teams: [{id: teamData.id, name: teamData.name}]}, {idField: 'id'}))
            }.bind(this));
            console.log(teamData.name, membersResponse.data.length, members);
            //team.organization = {login: organization.login, id: organization.id};
            //team.members = members
            //console.log("addTeamMembers", team.id, team.name, {members: members})
            promises.push(this.coordinatorObj.createOrUpdate({index: 'github-teams', type: 'github-team'}, teamWriter, teamData, {members: members}, {idField: 'id'}))
            console.log(promises);
            return Promise.all(promises)
        },

        processMembership: function(body)
        {
            switch(body.action) {
                case "added":
                    this.processMembers({data:[body.member]}, body.team).then(function() {
                        console.log('completed', body.member.login, body.team.name)
                        this.coordinatorObj.getQueueSize();
                        this.coordinatorObj.processQueue().then(console.log).catch(console.log)
                    }.bind(this)).catch(console.log)
                    break;
            }
        },

        processPRWebhook: function(body)
        {
            switch(body.action) {
                case 'synchronize':
                case 'opened':
                case 'edited':
                case 'reopened':
                    this.writePullRequest(body.pull_request);
                    break;
                case 'labeled':
                    this.processLabel(body); 
                    break;
                default: 
                    console.log('default unprocessed action: ' + body.action);
                    break;
            }
        }
    }
}