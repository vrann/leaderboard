//load prs and check that authors has the pr in its prs
var AWS = require('aws-sdk');
AWS.config.setPromisesDependency(require('bluebird'));

var integrityChecker = function(github, client, region, queueUrl) {
    AWS.config.setPromisesDependency(require('bluebird'));
    return {
        sqs: new AWS.SQS({region: region}),
        prs: {},
        fullPrs: {},
        members: {},
        exceptions: [],
        queueUrl: queueUrl,

        checkCountPrs: function() {
            return new Promise(function(resolve, reject) {
                //check count of prs on github and internall
                Promise.all([
                    github.getPullRequests({
                        user: 'magento',
                        repo: 'magento2',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento',
                        repo: 'magento2',
                        state: 'open'
                    }),

                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ee',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ee',
                        state: 'open'
                    }),

                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ce',
                        state: 'closed'
                    }),
                    github.getPullRequests({
                        user: 'magento-partners',
                        repo: 'magento2ce',
                        state: 'open'
                    }),

                    client.count({
                        index: 'github-prs',
                        type: 'github-pr',
                        body: {"query": 
                            {match_all:{}}
                        }
                    })
                ]).then(function(res) {
                    var total = 0;
                    var current = 0;
                    res.map(function(singleResult) {
                        if (singleResult.hasOwnProperty('total_count')) {
                            console.log(singleResult.total_count)
                            total += singleResult.total_count;
                        } else if (singleResult.hasOwnProperty('count')) {
                            current = singleResult.count;
                        }
                    })
                    console.log('Total', total, 'In Elastic', current);
                    var documentsToImport = []
                    if (total + 23 > current) {
                        this.exceptions.push({
                            error: 'prs count is less than necessary'
                        })
                        resolve('prs count is less than necessary')
                    } else if (total + 23 < current) {
                        console.log('Excessive PRs');
                        resolve('Excessive PRs')
                    }
                }.bind(this)).catch(reject)
            }.bind(this))
        },

        checkIndices: function() {
            return new Promise((resolve, reject) => {
                console.log(Object.keys(this))
                client.indices.exists({index: ['github-prs', 'github-prs-metadata', 'github-teams', 'github-members']}).then(result => {
                    if (!result) {
                        console.log(result)
                        this.exceptions.push({
                            error: 'index does not exists'
                        })
                        reject('Indices does not exists');
                    } else {
                        resolve('All indicies exists');
                    }
                }).catch(reject);
            })
        },

        checkMembers: function(key) {
            return new Promise(function(resolve, reject) {
                key = parseInt(key);
                memberPrs = this.members[key];
                errors = 0;
                if (this.members.hasOwnProperty(key)) {
                    memberPrs.map(function(pr){
                        if (!this.prs.hasOwnProperty(pr)) {
                            //console.log('pr creator is not a member');
                            this.exceptions.push({
                                error: 'pr is missing',
                                pr: pr,
                                member: key
                            })
                            errors++;
                        } else if (this.prs[pr] != key) {
                            //console.log('pr creator is not a member');
                            this.exceptions.push({
                                error: 'pr creator is not a member',
                                pr: pr,
                                member: key
                            })
                            errors++
                        }
                    }, this)
                }
                if (errors > 0) {
                    reject('Inconsistencies in teams and members')
                } else {
                    resolve('Members and Teams are consistent')
                }
            }.bind(this))
        },

        checkPrs: function(key) {
                key = parseInt(key);
                member = this.prs[key];
                if (!this.members.hasOwnProperty(member)) {
                    //console.log('member is missing');
                    this.exceptions.push({
                        error: 'member is missing',
                        pr: key,
                        member: member
                    })
                } else if (this.members[member].indexOf(key) == -1) {
                    //console.log('member does not have pr');
                    this.exceptions.push({
                        error: 'member does not have pr',
                        pr: key,
                        member: member
                    })
                }
        },

        sendExceptions: function(response) {
            console.log(response, this.exceptions)
            messages = [];
            // this.exceptions.map(function(exception) {
            //     switch (exception.error) {
            //         case 'index does not exists':
            //            messages.push({action: 'syncPRs'}) 
            //            messages.push({action: 'syncTeams'})
            //            break;  
            //     }
            // }.bind(this))
            if (this.exceptions.length > 0) {
                messages.push({action: 'syncPRs'}) 
                messages.push({action: 'syncTeams'})
            }

            promises = []
            messages.map(function(message) {
                var params = {
                    MessageBody: JSON.stringify(message),
                    QueueUrl: this.queueUrl,
                    DelaySeconds: 0
                }
                promises.push(this.sqs.sendMessage(params).promise())
            }.bind(this))
            console.log(messages, promises);
            return Promise.all(promises)
        },

        prsProcessor: function(item) {
            this.prs[item.id] = item.user_id;
        },

        loadDataElastic: function(config, callback, shouldScroll) {
            config.scroll = '60s';
            callFunc = client.search
            if (config.body.hasOwnProperty('scroll_id')) {
                callFunc = client.scroll
            }
            return callFunc.call(client, config).then(
                response => {
                    callback.call(this, response)
                    if (shouldScroll(response.hits.total)) {
                        return this.loadDataElastic({
                            body: {
                                scroll_id: response._scroll_id
                            }
                        }, callback, shouldScroll)
                    } else {
                        return new Promise(function(resolve, reject) {resolve("Finished")});
                    }
                }
            )
        },

        checkIntegrity: function() {
            this.checkIndices.call(this).then(result => {
                //load prs metadata
                console.log(result, this.exceptions)
                return this.loadDataElastic({
                    index: 'github-prs-metadata',
                    type: 'github-pr-metadata',
                    _source: ["id", "user_id"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }    
                }, response => {
                    response.hits.hits.forEach(
                        hit => {
                            this.prs[hit._source.id] = hit._source.user_id
                        }
                    );
                }, hitsTotal => {
                    console.log(hitsTotal, Object.keys(this.prs).length)
                    return hitsTotal > Object.keys(this.prs).length
                }).catch(console.log)
            }).then(result => {
                //load prs and check that there is corresponding pr metadata
                return this.loadDataElastic({
                    index: 'github-prs',
                    type: 'github-pr',
                    _source: ["id"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }    
                }, response => {
                    response.hits.hits.map(item => {
                        if (!this.prs.hasOwnProperty(item._source.id)) {
                            this.exceptions.push({
                                error: 'there is no metadata for the pr',
                                pr: item.id
                            })
                        }
                        this.fullPrs[item._source.id] = true;
                    }, this)
                }, hitsTotal => {
                    console.log(hitsTotal, Object.keys(this.fullPrs).length)
                    return hitsTotal > Object.keys(this.fullPrs).length
                }).catch(console.log)
            }).then(result => {
                Object.keys(this.prs).map(function(id) {
                    if (!this.fullPrs.hasOwnProperty(id)) {
                        this.exceptions.push({
                            error: 'there is no full pr for metadata',
                            pr: id
                        })
                    }
                }, this)
                return new Promise(function(resolve, reject) {resolve("Finished")});
            }).then(result => {
                //load members
                return this.loadDataElastic({
                    index: 'github-members',
                    type: 'github-member',
                    _source: ["id", "prs"],
                    size: 1000,
                    body: {
                        query:{
                            match_all:{}
                        }
                    }
                }, response => {
                    response.hits.hits.map(item => {
                        this.members[item._source.id] = item._source.prs;
                    })    
                }, hitsTotal => {
                    console.log(hitsTotal, Object.keys(this.members).length)
                    return hitsTotal > Object.keys(this.members).length
                })
            }).then(result => {
                //check that members assigned to pr has the pr
                Object.keys(this.prs).map(this.checkPrs, this)
                return new Promise(function(resolve, reject) {resolve("Finished")});
            }).then(result => {
                 //check that prs assigned to the member has the member
                Object.keys(this.members).map(this.checkMembers, this)
                return new Promise(function(resolve, reject) {resolve("Finished")});
            })
            .then(this.checkCountPrs.bind(this))
            .then(result => {
                console.log(this.exceptions)
                return this.sendExceptions()
            })
            .then(console.log)
            .catch(response => {
                console.log(response)
                this.sendExceptions   
            })
        }
    }    
}

module.exports = integrityChecker